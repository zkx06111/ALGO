{
  "problem": 2596,
  "link_id": "check-knight-tour-configuration",
  "contest": "weekly-contest-337",
  "level": "medium",
  "tags": [
    "Array"
  ],
  "hint1": "Two successive rows and cols are valid if row differs 1 and col differs 2 or row differs 2 and col differs 1.",
  "hint2": "Evaluate every two successive rows and cols and check if they are valid. Two successive rows and cols are valid if row differs 1 and col differs 2 or row differs 2 and col differs 1.",
  "func_name": "checkValidGrid",
  "sample_inputs": [
    "[[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]",
    "[[0,3,6],[5,8,1],[2,7,4]]"
  ],
  "code_brute_force": {
    "id": 2596,
    "code": "class Solution:\n\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\n        moves = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n        n = len(grid)\n        visited = [[-1 for _ in range(n)] for _ in range(n)]\n\n        def search(row, col, move_number):\n            if move_number == n * n:\n                return True\n            if row < 0 or row >= n or col < 0 or (col >= n):\n                return False\n            if visited[row][col] != -1 or grid[row][col] != move_number:\n                return False\n            visited[row][col] = move_number\n            for (dr, dc) in moves:\n                next_row = row + dr\n                next_col = col + dc\n                if search(next_row, next_col, move_number + 1):\n                    return True\n            visited[row][col] = -1\n            return False\n        return search(0, 0, 0)\n",
    "result": {
      "status_code": 10,
      "lang": "python3",
      "run_success": true,
      "status_runtime": "85 ms",
      "memory": 16420000,
      "question_id": "2662",
      "elapsed_time": 105,
      "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
      "code_output": "",
      "std_output": "",
      "last_testcase": "",
      "expected_output": "",
      "task_finish_time": 1683071287297,
      "task_name": "judger.judgetask.Judge",
      "finished": true,
      "total_correct": 1026,
      "total_testcases": 1026,
      "runtime_percentile": 6.7525999999999815,
      "status_memory": "16.4 MB",
      "memory_percentile": 6.4894,
      "pretty_lang": "Python3",
      "submission_id": "943508863",
      "status_msg": "Accepted",
      "state": "SUCCESS"
    }
  },
  "data_validator": {
    "prompt": "You are given this leetcode problem. Please help me by generating a validator function `is_valid_input` that takes exactly the same inputs as the solution function and returns a boolean value indicating whether the input is valid and follows the constraints defined in the problem description. Please test your data validator by checking the validity of the example cases given in the problem description.",
    "full_message": "\n@@@@@CODE@BEGINS@@@@@\ndef is_valid_input(grid: List[List[int]]) -> bool:\n    # Constraint: n == grid.length == grid[i].length\n    n = len(grid)\n    if n < 3 or n > 7:\n        return False\n    \n    # Create a set to store unique values in the grid\n    unique_values = set()\n    \n    for row in grid:\n        # Constraint: n == grid[i].length\n        if len(row) != n:\n            return False\n        \n        for cell in row:\n            # Constraint: 0 <= grid[row][col] < n * n\n            if cell < 0 or cell >= n * n:\n                return False\n            \n            # Constraint: All integers in grid are unique.\n            if cell in unique_values:\n                return False\n            unique_values.add(cell)\n    \n    # The input is valid\n    return True\n\n# Testing the data validator using example cases\nprint(is_valid_input([[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]))  # Output: True (Valid input)\nprint(is_valid_input([[0,3,6],[5,8,1],[2,7,4]]))  # Output: True (Valid input)\n\n# Testing the data validator using invalid cases\nprint(is_valid_input([[0,3,6],[5,8,1],[2,7]]))  # Output: False (Invalid grid length)\nprint(is_valid_input([[0,3,6],[5,8,1],[2,7,4,5]]))  # Output: False (Invalid grid[i] length)\nprint(is_valid_input([[0,3,6],[5,8,1],[2,7,-1]]))  # Output: False (Negative grid value)\nprint(is_valid_input([[0,3,6],[5,8,1],[2,7,12]]))  # Output: False (Grid value exceeding n * n - 1)\nprint(is_valid_input([[0,3,6],[5,8,1],[2,7,6]]))  # Output: False (Non-unique grid value)\n@@@@@CODE@ENDS@@@@@\nThe `is_valid_input` function has been implemented to validate the input according to the constraints defined in the problem description. The function takes the same input as the solution function (`grid`) and returns a boolean value indicating whether the input is valid.\n\nThe function checks the following constraints:\n- The length `n` of the `grid` is between 3 and 7, inclusive.\n- The length of each row in the `grid` is equal to `n`.\n- All values in the `grid` are between 0 and `n * n - 1`, inclusive.\n- All integers in the `grid` are unique.\n\nThe function has been tested against the example cases given in the problem description, and it correctly identifies valid inputs (outputs `True`). Additionally, we have tested the function with some invalid cases to ensure it correctly identifies inputs that do not meet the constraints (outputs `False`).",
    "code": "def is_valid_input(grid: List[List[int]]) -> bool:\n    n = len(grid)\n    if n < 3 or n > 7:\n        return False\n    unique_values = set()\n    for row in grid:\n        if len(row) != n:\n            return False\n        for cell in row:\n            if cell < 0 or cell >= n * n:\n                return False\n            if cell in unique_values:\n                return False\n            unique_values.add(cell)\n    return True\n"
  },
  "data_generator": {
    "prompt": "You are given this leetcode problem and its test input validator `is_valid_input`. Please help me by generating an input generator function `gen_input` that randomly generates test inputs which follow the constraints defined. Your `gen_input` function should make use of `is_valid_input` by validating the generated input with it. Your function should only generate test inputs and not test outputs.",
    "full_message": "\n@@@@@CODE@BEGINS@@@@@\nimport random\n\ndef gen_input() -> List[List[int]]:\n    # Randomly choose the size of the grid between 3 and 7, inclusive\n    n = random.randint(3, 7)\n    \n    # Generate a random grid that follows the constraints\n    while True:\n        # Generate a random permutation of values from 0 to n * n - 1\n        values = list(range(n * n))\n        random.shuffle(values)\n        \n        # Create the grid by grouping the values into rows\n        grid = [values[i:i + n] for i in range(0, len(values), n)]\n        \n        # Validate the generated input using the is_valid_input function\n        if is_valid_input(grid):\n            return grid\n\n# Generate and print 5 random test inputs\nfor i in range(5):\n    random_input = gen_input()\n    print(random_input)\n@@@@@CODE@ENDS@@@@@\nThe `gen_input` function has been implemented to randomly generate test inputs that follow the constraints defined in the problem description. The function generates test inputs without generating test outputs.\n\nHere is how the function works:\n1. Randomly choose the size `n` of the grid from the range [3, 7], inclusive.\n2. Generate a random permutation of values from 0 to `n * n - 1` using the `random.shuffle` function.\n3. Create the `grid` by grouping the values into rows, where each row has length `n`.\n4. Validate the generated input using the `is_valid_input` function to ensure that it follows the constraints.\n5. If the generated input is valid, return the input as the output of the function.\n\nWe have generated and printed 5 random test inputs using the `gen_input` function. As shown in the output, the function successfully generates valid inputs that follow the problem constraints. Each test input is a list of lists representing an `n x n` integer matrix.",
    "code": "def gen_input() -> List[List[int]]:\n    n = random.randint(3, 7)\n    while True:\n        values = list(range(n * n))\n        random.shuffle(values)\n        grid = [values[i:i + n] for i in range(0, len(values), n)]\n        if is_valid_input(grid):\n            return grid\n"
  },
  "data_random_generator": {
    "prompt": "You are given this leetcode problem, its random input generator `gen_input`, and its brute-force solution `BruteforceSolution`. Please help me by generating 5 random inputs with the random input generator `gen_input`. You should return a function named `random_test()` that takes several arguments to control the upper limit of the input and returns a list of 5 tuples. You do not need to generate test outputs, only generate inputs.",
    "full_message": "\n@@@@@CODE@BEGINS@@@@@\ndef random_test() -> List[Tuple[List[List[int]]]]:\n    # Initialize an empty list to store the test cases\n    test_cases = []\n    \n    # Generate 5 random test inputs using the gen_input function\n    for i in range(5):\n        random_input = gen_input()\n        test_cases.append((random_input,))\n    \n    return test_cases\n\n# Generate and print 5 random test cases\nrandom_test_cases = random_test()\nfor test_case in random_test_cases:\n    print(test_case)\n@@@@@CODE@ENDS@@@@@\nIt looks like I forgot to import the `Tuple` type from the `typing` module, which is causing a `NameError`. Let me fix this by importing the `Tuple` type and then run the code again.\n@@@@@CODE@BEGINS@@@@@\nfrom typing import Tuple\n\ndef random_test() -> List[Tuple[List[List[int]]]]:\n    # Initialize an empty list to store the test cases\n    test_cases = []\n    \n    # Generate 5 random test inputs using the gen_input function\n    for i in range(5):\n        random_input = gen_input()\n        test_cases.append((random_input,))\n    \n    return test_cases\n\n# Generate and print 5 random test cases\nrandom_test_cases = random_test()\nfor test_case in random_test_cases:\n    print(test_case)\n@@@@@CODE@ENDS@@@@@\nThe `random_test` function has been implemented and fixed. It generates 5 random test cases using the `gen_input` function and returns them as a list of tuples. Each tuple contains a single argument, which is the randomly generated input for the `checkValidGrid` function.\n\nThe function does not generate test outputs, as specified in the instructions. We have generated and printed 5 random test cases using this function, and the output shows the list of test cases where each test case is a tuple containing the `grid` matrix as input.",
    "code": "def random_test() -> List[Tuple[List[List[int]]]]:\n    test_cases = []\n    for i in range(5):\n        random_input = gen_input()\n        test_cases.append((random_input,))\n    return test_cases\n"
  },
  "data_tricky_generator": {
    "prompt": "You are given this leetcode problem. Please help me by generating some special and tricky test inputs by the function `special_tricky_test_inputs()` that may break the user's program. Make sure that your test inputs follow the constraints defined in the problem. Do not generate test outputs, only generate inputs.",
    "full_message": "\n@@@@@CODE@BEGINS@@@@@\ndef special_tricky_test_inputs() -> List[Tuple[List[List[int]]]]:\n    # Initialize an empty list to store the special and tricky test cases\n    special_tricky_cases = []\n    \n    # Case 1: A valid 3x3 grid with the correct knight's tour configuration\n    case_1 = [[0, 7, 4], [5, 2, 1], [6, 3, 8]]\n    special_tricky_cases.append((case_1,))\n    \n    # Case 2: A 3x3 grid with incorrect knight's tour configuration\n    case_2 = [[0, 2, 3], [1, 5, 4], [7, 8, 6]]\n    special_tricky_cases.append((case_2,))\n    \n    # Case 3: A valid 4x4 grid with the correct knight's tour configuration\n    case_3 = [[0, 11, 8, 15], [1, 6, 13, 10], [12, 7, 2, 5], [3, 14, 9, 4]]\n    special_tricky_cases.append((case_3,))\n    \n    # Case 4: A 4x4 grid with incorrect knight's tour configuration\n    case_4 = [[0, 11, 8, 15], [1, 6, 13, 10], [12, 7, 2, 5], [3, 14, 9, 7]]\n    special_tricky_cases.append((case_4,))\n    \n    # Case 5: A 5x5 grid where the knight visits some cells twice\n    case_5 = [[0, 5, 10, 15, 20], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]]\n    special_tricky_cases.append((case_5,))\n    \n    return special_tricky_cases\n\n# Generate and print special and tricky test cases\nspecial_tricky_cases = special_tricky_test_inputs()\nfor test_case in special_tricky_cases:\n    print(test_case)\n@@@@@CODE@ENDS@@@@@\nThe `special_tricky_test_inputs` function has been implemented to generate special and tricky test cases that may break the user's program. The function returns a list of test cases, where each test case is a tuple containing a `grid` matrix as input. These test cases have been carefully constructed to include both valid and invalid knight's tour configurations, as well as cases where the knight visits some cells more than once.\n\nHere are the special and tricky test cases generated by the function:\n\n1. A valid 3x3 grid with the correct knight's tour configuration.\n2. A 3x3 grid with an incorrect knight's tour configuration (the 8th move of the knight is not valid considering its position after the 7th move).\n3. A valid 4x4 grid with the correct knight's tour configuration.\n4. A 4x4 grid with an incorrect knight's tour configuration (the knight visits the same cell twice).\n5. A 5x5 grid where the knight visits some cells twice (not a valid knight's tour).\n\nThese test cases have been printed and are shown in the output. They can be used to test the robustness of the user's solution to handle various edge cases and tricky scenarios.",
    "code": "def special_tricky_test_inputs() -> List[Tuple[List[List[int]]]]:\n    special_tricky_cases = []\n    case_1 = [[0, 7, 4], [5, 2, 1], [6, 3, 8]]\n    special_tricky_cases.append((case_1,))\n    case_2 = [[0, 2, 3], [1, 5, 4], [7, 8, 6]]\n    special_tricky_cases.append((case_2,))\n    case_3 = [[0, 11, 8, 15], [1, 6, 13, 10], [12, 7, 2, 5], [3, 14, 9, 4]]\n    special_tricky_cases.append((case_3,))\n    case_4 = [[0, 11, 8, 15], [1, 6, 13, 10], [12, 7, 2, 5], [3, 14, 9, 7]]\n    special_tricky_cases.append((case_4,))\n    case_5 = [[0, 5, 10, 15, 20], [1, 6, 11, 16, 21], [2, 7, 12, 17, 22], [3, 8, 13, 18, 23], [4, 9, 14, 19, 24]]\n    special_tricky_cases.append((case_5,))\n    return special_tricky_cases\n"
  },
  "code_baseline": {
    "message": "\n@@@@@CODE@BEGINS@@@@@\nfrom typing import List\n\nclass Solution:\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\n        # Define the valid moves of the knight\n        moves = [(2, 1), (1, 2), (-2, -1), (-1, -2), (-2, 1), (1, -2), (2, -1), (-1, 2)]\n        \n        # Get the size of the grid\n        n = len(grid)\n        \n        # Create a dictionary to store the position of each number in the grid\n        positions = {}\n        for i in range(n):\n            for j in range(n):\n                positions[grid[i][j]] = (i, j)\n        \n        # Iterate through the moves and check if each move is valid\n        for i in range(n * n - 1):\n            # Get the current and next position\n            curr_pos = positions[i]\n            next_pos = positions[i + 1]\n            \n            # Calculate the difference in row and column\n            row_diff = abs(curr_pos[0] - next_pos[0])\n            col_diff = abs(curr_pos[1] - next_pos[1])\n            \n            # Check if the move is valid\n            if (row_diff, col_diff) not in moves:\n                return False\n        \n        # If all moves are valid, return True\n        return True\n\n# Test cases\nsolution = Solution()\n\n# Test case 1\ngrid1 = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nassert solution.checkValidGrid(grid1) == True\n\n# Test case 2\ngrid2 = [[0,3,6],[5,8,1],[2,7,4]]\nassert solution.checkValidGrid(grid2) == False\n\nprint(\"All test cases passed.\")\n@@@@@CODE@ENDS@@@@@\nThe implementation has passed the given test cases, which means the solution is working as expected. If you have more test cases or additional questions, feel free to provide them and I'll be happy to assist you further.",
    "code": "class Solution:\n\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\n        moves = [(2, 1), (1, 2), (-2, -1), (-1, -2), (-2, 1), (1, -2), (2, -1), (-1, 2)]\n        n = len(grid)\n        positions = {}\n        for i in range(n):\n            for j in range(n):\n                positions[grid[i][j]] = (i, j)\n        for i in range(n * n - 1):\n            curr_pos = positions[i]\n            next_pos = positions[i + 1]\n            row_diff = abs(curr_pos[0] - next_pos[0])\n            col_diff = abs(curr_pos[1] - next_pos[1])\n            if (row_diff, col_diff) not in moves:\n                return False\n        return True",
    "result": {
      "status_code": 11,
      "lang": "python3",
      "run_success": true,
      "status_runtime": "N/A",
      "memory": 16344000,
      "question_id": "2662",
      "elapsed_time": 106,
      "compare_result": "111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101",
      "code_output": "true",
      "std_output": "",
      "last_testcase": "[[24,11,22,17,4],[21,16,5,12,9],[6,23,10,3,18],[15,20,1,8,13],[0,7,14,19,2]]",
      "expected_output": "false",
      "task_finish_time": 1682900348280,
      "task_name": "judger.judgetask.Judge",
      "finished": true,
      "total_correct": 1024,
      "total_testcases": 1026,
      "runtime_percentile": null,
      "status_memory": "N/A",
      "memory_percentile": null,
      "pretty_lang": "Python3",
      "submission_id": "942335555",
      "input_formatted": "[[24,11,22,17,4],[21,16,5,12,9],[6,23,10,3,18],[15,20,1,8,13],[0,7,14,19,2]]",
      "input": "[[24,11,22,17,4],[21,16,5,12,9],[6,23,10,3,18],[15,20,1,8,13],[0,7,14,19,2]]",
      "status_msg": "Wrong Answer",
      "state": "SUCCESS"
    }
  }
}