{
  "problem": 2583,
  "link_id": "kth-largest-sum-in-a-binary-tree",
  "contest": "weekly-contest-335",
  "level": "medium",
  "tags": [
    "Binary Tree",
    "Depth-First Search"
  ],
  "hint1": "Depth-first search the tree and keep track of depth and sum of values.",
  "hint2": "Depth-first search the tree based on the TreeNode, and then summing the values of node with the same depth in a list. Then find the kth largest element in the list.",
  "func_name": "kthLargestLevelSum",
  "sample_inputs": [
    "[5,8,9,2,1,3,7,4,6]\n2",
    "[1,2,null,3]\n1"
  ],
  "code_brute_force": {
    "id": 2583,
    "code": "class TreeNode:\n\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        level_sums = []\n        queue = [root]\n        while queue:\n            level_size = len(queue)\n            level_sum = 0\n            for i in range(level_size):\n                node = queue.pop(0)\n                level_sum += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            level_sums.append(level_sum)\n        level_sums.sort(reverse=True)\n        return level_sums[k - 1] if k <= len(level_sums) else -1\n",
    "result": {
      "status_code": 10,
      "lang": "python3",
      "run_success": true,
      "status_runtime": "1001 ms",
      "memory": 57504000,
      "question_id": "2646",
      "elapsed_time": 1044,
      "compare_result": "111111111111111111111111111111111111111111111",
      "code_output": "",
      "std_output": "",
      "last_testcase": "",
      "expected_output": "",
      "task_finish_time": 1683071012952,
      "task_name": "judger.judgetask.Judge",
      "finished": true,
      "total_correct": 45,
      "total_testcases": 45,
      "runtime_percentile": 15.56750000000001,
      "status_memory": "57.5 MB",
      "memory_percentile": 23.50230000000004,
      "pretty_lang": "Python3",
      "submission_id": "943507864",
      "status_msg": "Accepted",
      "state": "SUCCESS"
    }
  },
  "data_validator": {
    "prompt": "You are given this leetcode problem. Please help me by generating a validator function `is_valid_input` that takes exactly the same inputs as the solution function and returns a boolean value indicating whether the input is valid and follows the constraints defined in the problem description. Please test your data validator by checking the validity of the example cases given in the problem description.",
    "full_message": "To create the `is_valid_input` validator function, we need to check the following constraints mentioned in the problem description:\n\n1. The number of nodes in the tree is `n`.\n2. `2 <= n <= 10^5`\n3. `1 <= Node.val <= 10^6`\n4. `1 <= k <= n`\n\nThe validator function will take the same inputs as the solution function: `root` (the root of a binary tree) and `k` (a positive integer). It will return `True` if the inputs satisfy the constraints and `False` otherwise.\n\nLet's implement the `is_valid_input` function:\n\n```python\ndef is_valid_input(root: TreeNode, k: int) -> bool:\n    if not root:\n        return False\n    if not isinstance(k, int) or k < 1:\n        return False\n    node_count = 0\n    node_values = set()\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        node_count += 1\n        node_values.add(node.val)\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    # Check constraints on n, k, and Node.val\n    return (\n        2 <= node_count <= 10**5 and\n        1 <= k <= node_count and\n        all(1 <= val <= 10**6 for val in node_values)\n    )\n```\n\nNow, let's test the data validator by checking the validity of the example cases given in the problem description.\n@@@@@CODE@BEGINS@@@@@\ndef is_valid_input(root: TreeNode, k: int) -> bool:\r\n    if not root:\r\n        return False\r\n    if not isinstance(k, int) or k < 1:\r\n        return False\r\n    node_count = 0\r\n    node_values = set()\r\n    queue = [root]\r\n    while queue:\r\n        node = queue.pop(0)\r\n        node_count += 1\r\n        node_values.add(node.val)\r\n        if node.left:\r\n            queue.append(node.left)\r\n        if node.right:\r\n            queue.append(node.right)\r\n    # Check constraints on n, k, and Node.val\r\n    return (\r\n        2 <= node_count <= 10**5 and\r\n        1 <= k <= node_count and\r\n        all(1 <= val <= 10**6 for val in node_values)\r\n    )\r\n\r\n# Testing the validator function\r\ntest_case_1_validity = is_valid_input(root1, 2)  # Example 1\r\ntest_case_2_validity = is_valid_input(root2, 1)  # Example 2\r\n\r\ntest_case_1_validity, test_case_2_validity\n@@@@@CODE@ENDS@@@@@\nThe results of the input validation for the example cases are as follows:\n\n- For Example 1, the input is `root = [5,8,9,2,1,3,7,4,6], k = 2`, and the validator function `is_valid_input` returns `True`, indicating that the input is valid and satisfies the constraints.\n\n- For Example 2, the input is `root = [1,2,null,3], k = 1`, and the validator function `is_valid_input` returns `True`, indicating that the input is valid and satisfies the constraints.\n\nTherefore, the `is_valid_input` validator function works correctly and validates the inputs according to the constraints defined in the problem description.",
    "code": "def is_valid_input(root: TreeNode, k: int) -> bool:\n    if not root:\n        return False\n    if not isinstance(k, int) or k < 1:\n        return False\n    node_count = 0\n    node_values = set()\n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        node_count += 1\n        node_values.add(node.val)\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    return 2 <= node_count <= 10 ** 5 and 1 <= k <= node_count and all((1 <= val <= 10 ** 6 for val in node_values))\n"
  },
  "data_generator": {
    "prompt": "You are given this leetcode problem and its test input validator `is_valid_input`. Please help me by generating an input generator function `gen_input` that randomly generates test inputs which follow the constraints defined. Your `gen_input` function should make use of `is_valid_input` by validating the generated input with it. Your function should only generate test inputs and not test outputs.",
    "full_message": "To generate valid test inputs for the problem, we can create a `gen_input` function that generates random binary trees and random values for `k`. The function will ensure that the generated inputs satisfy the constraints defined in the problem description by using the `is_valid_input` validator function.\n\nLet's implement the `gen_input` function:\n\n1. Generate a random number `n` for the number of nodes in the binary tree within the range `[2, min(50, 10^5)]`. We limit the upper bound to 50 for reasonable testing purposes.\n\n2. Generate a random binary tree with `n` nodes. The values of each node will be randomly chosen from the range `[1, 10^6]`.\n\n3. Generate a random value for `k` within the range `[1, n]`.\n\n4. Validate the generated inputs using the `is_valid_input` function. If the inputs are valid, return them; otherwise, try again.\n\n```python\nimport random\n\ndef gen_input():\n    def generate_random_tree(n: int) -> TreeNode:\n        if n == 0:\n            return None\n        root_val = random.randint(1, 10**6)\n        root = TreeNode(root_val)\n        nodes = [root]\n        for _ in range(1, n):\n            new_node = TreeNode(random.randint(1, 10**6))\n            parent = random.choice(nodes)\n            if parent.left is None:\n                parent.left = new_node\n            elif parent.right is None:\n                parent.right = new_node\n            else:\n                nodes.remove(parent)\n            nodes.append(new_node)\n        return root\n\n    while True:\n        n = random.randint(2, min(50, 10**5))\n        root = generate_random_tree(n)\n        k = random.randint(1, n)\n        if is_valid_input(root, k):\n            return root, k\n```\n\nNote that we limit the maximum number of nodes to 50 for testing purposes. In practice, we could increase this limit to the original constraint `10^5`. The function will keep generating inputs until it produces valid ones according to the constraints.\n\nLet's test the `gen_input` function to see if it generates valid inputs. We will generate five random test inputs and check their validity using the `is_valid_input` function.\n@@@@@CODE@BEGINS@@@@@\n# Testing the gen_input function\r\ntest_inputs = [gen_input() for _ in range(5)]\r\ntest_input_validity = [is_valid_input(root, k) for root, k in test_inputs]\r\n\r\ntest_inputs, test_input_validity\n@@@@@CODE@ENDS@@@@@\nThe `gen_input` function generated five random test inputs, which are represented as tuples containing the root of the binary tree and the value of `k`. The validity of each input was checked using the `is_valid_input` function, and the results show that all the generated inputs are valid (`True`).\n\nThis confirms that the `gen_input` function generates valid test inputs that satisfy the constraints defined in the problem description.",
    "code": ""
  },
  "data_random_generator": {
    "prompt": "You are given this leetcode problem, its random input generator `gen_input`, and its brute-force solution `BruteforceSolution`. Please help me by generating 5 random inputs with the random input generator `gen_input`. You should return a function named `random_test()` that takes several arguments to control the upper limit of the input and returns a list of 5 tuples. You do not need to generate test outputs, only generate inputs.",
    "full_message": "\n@@@@@CODE@BEGINS@@@@@\ndef random_test(n_upper_limit=50):\r\n    def gen_input(n_upper_limit):\r\n        def generate_random_tree(n: int) -> TreeNode:\r\n            if n == 0:\r\n                return None\r\n            root_val = random.randint(1, 10**6)\r\n            root = TreeNode(root_val)\r\n            nodes = [root]\r\n            for _ in range(1, n):\r\n                new_node = TreeNode(random.randint(1, 10**6))\r\n                parent = random.choice(nodes)\r\n                if parent.left is None:\r\n                    parent.left = new_node\r\n                elif parent.right is None:\r\n                    parent.right = new_node\r\n                else:\r\n                    nodes.remove(parent)\r\n                nodes.append(new_node)\r\n            return root\r\n\r\n        while True:\r\n            n = random.randint(2, min(n_upper_limit, 10**5))\r\n            root = generate_random_tree(n)\r\n            k = random.randint(1, n)\r\n            if is_valid_input(root, k):\r\n                return root, k\r\n\r\n    # Generate 5 random inputs\r\n    random_inputs = [gen_input(n_upper_limit) for _ in range(5)]\r\n    return random_inputs\r\n\r\n# Testing the random_test function\r\nrandom_inputs = random_test()\r\nrandom_inputs\n@@@@@CODE@ENDS@@@@@\nThe `random_test` function successfully generated 5 random inputs, each represented as a tuple containing the root of the binary tree and the value of `k`. The generated inputs are within the constraints defined in the problem description, and the upper limit for the number of nodes in the binary tree (`n_upper_limit`) can be controlled by passing it as an argument to the `random_test` function.\n\nThese generated inputs can be used for testing the `BruteforceSolution` implementation or other solution approaches to the problem.",
    "code": "def random_test(n_upper_limit=50):\n\n    def gen_input(n_upper_limit):\n\n        def generate_random_tree(n: int) -> TreeNode:\n            if n == 0:\n                return None\n            root_val = random.randint(1, 10 ** 6)\n            root = TreeNode(root_val)\n            nodes = [root]\n            for _ in range(1, n):\n                new_node = TreeNode(random.randint(1, 10 ** 6))\n                parent = random.choice(nodes)\n                if parent.left is None:\n                    parent.left = new_node\n                elif parent.right is None:\n                    parent.right = new_node\n                else:\n                    nodes.remove(parent)\n                nodes.append(new_node)\n            return root\n        while True:\n            n = random.randint(2, min(n_upper_limit, 10 ** 5))\n            root = generate_random_tree(n)\n            k = random.randint(1, n)\n            if is_valid_input(root, k):\n                return (root, k)\n    random_inputs = [gen_input(n_upper_limit) for _ in range(5)]\n    return random_inputs\n"
  },
  "data_tricky_generator": {
    "prompt": "You are given this leetcode problem. Please help me by generating some special and tricky test inputs by the function `special_tricky_test_inputs()` that may break the user's program. Make sure that your test inputs follow the constraints defined in the problem. Do not generate test outputs, only generate inputs.",
    "full_message": "To generate special and tricky test inputs that may challenge the user's program, we can consider several scenarios that require careful handling:\n\n1. A binary tree with only two nodes (minimum number of nodes allowed by constraints).\n2. A binary tree with all nodes having the same value.\n3. A binary tree with nodes having the maximum allowed values (10^6).\n4. A binary tree with only one branch (a degenerate tree, i.e., a linked list).\n5. A balanced binary tree with `k` equal to the number of levels in the tree.\n\nLet's implement the `special_tricky_test_inputs` function to create these test cases:\n\n```python\ndef special_tricky_test_inputs():\n    # Scenario 1: A binary tree with only two nodes\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    \n    # Scenario 2: A binary tree with all nodes having the same value\n    root2 = TreeNode(3)\n    root2.left = TreeNode(3)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(3)\n    root2.left.right = TreeNode(3)\n    \n    # Scenario 3: A binary tree with nodes having the maximum allowed values (10^6)\n    root3 = TreeNode(10**6)\n    root3.left = TreeNode(10**6)\n    root3.right = TreeNode(10**6)\n    \n    # Scenario 4: A binary tree with only one branch (a degenerate tree)\n    root4 = TreeNode(1)\n    root4.right = TreeNode(2)\n    root4.right.right = TreeNode(3)\n    root4.right.right.right = TreeNode(4)\n    \n    # Scenario 5: A balanced binary tree with k equal to the number of levels in the tree\n    root5 = TreeNode(5)\n    root5.left = TreeNode(8)\n    root5.right = TreeNode(9)\n    root5.left.left = TreeNode(2)\n    root5.left.right = TreeNode(1)\n    root5.right.left = TreeNode(3)\n    root5.right.right = TreeNode(7)\n    \n    # Test inputs\n    test_inputs = [\n        (root1, 1),\n        (root2, 2),\n        (root3, 1),\n        (root4, 3),\n        (root5, 3)\n    ]\n    return test_inputs\n```\n\nLet's call the function `special_tricky_test_inputs` to generate the test inputs:\n@@@@@CODE@BEGINS@@@@@\ndef special_tricky_test_inputs():\r\n    # Scenario 1: A binary tree with only two nodes\r\n    root1 = TreeNode(1)\r\n    root1.left = TreeNode(2)\r\n    \r\n    # Scenario 2: A binary tree with all nodes having the same value\r\n    root2 = TreeNode(3)\r\n    root2.left = TreeNode(3)\r\n    root2.right = TreeNode(3)\r\n    root2.left.left = TreeNode(3)\r\n    root2.left.right = TreeNode(3)\r\n    \r\n    # Scenario 3: A binary tree with nodes having the maximum allowed values (10^6)\r\n    root3 = TreeNode(10**6)\r\n    root3.left = TreeNode(10**6)\r\n    root3.right = TreeNode(10**6)\r\n    \r\n    # Scenario 4: A binary tree with only one branch (a degenerate tree)\r\n    root4 = TreeNode(1)\r\n    root4.right = TreeNode(2)\r\n    root4.right.right = TreeNode(3)\r\n    root4.right.right.right = TreeNode(4)\r\n    \r\n    # Scenario 5: A balanced binary tree with k equal to the number of levels in the tree\r\n    root5 = TreeNode(5)\r\n    root5.left = TreeNode(8)\r\n    root5.right = TreeNode(9)\r\n    root5.left.left = TreeNode(2)\r\n    root5.left.right = TreeNode(1)\r\n    root5.right.left = TreeNode(3)\r\n    root5.right.right = TreeNode(7)\r\n    \r\n    # Test inputs\r\n    test_inputs = [\r\n        (root1, 1),\r\n        (root2, 2),\r\n        (root3, 1),\r\n        (root4, 3),\r\n        (root5, 3)\r\n    ]\r\n    return test_inputs\r\n\r\n# Generate special and tricky test inputs\r\nspecial_tricky_inputs = special_tricky_test_inputs()\r\nspecial_tricky_inputs\n@@@@@CODE@ENDS@@@@@\nThe `special_tricky_test_inputs` function has successfully generated special and tricky test inputs that may challenge the user's program:\n\n1. A binary tree with only two nodes and `k=1`.\n2. A binary tree with all nodes having the same value and `k=2`.\n3. A binary tree with nodes having the maximum allowed values (10^6) and `k=1`.\n4. A binary tree with only one branch (a degenerate tree) and `k=3`.\n5. A balanced binary tree with `k` equal to the number of levels in the tree (`k=3`).\n\nThese test inputs are represented as tuples containing the root of the binary tree and the value of `k`. These inputs can be used to test the correctness and robustness of the user's program or solution approaches to the problem.",
    "code": "def special_tricky_test_inputs():\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root2 = TreeNode(3)\n    root2.left = TreeNode(3)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(3)\n    root2.left.right = TreeNode(3)\n    root3 = TreeNode(10 ** 6)\n    root3.left = TreeNode(10 ** 6)\n    root3.right = TreeNode(10 ** 6)\n    root4 = TreeNode(1)\n    root4.right = TreeNode(2)\n    root4.right.right = TreeNode(3)\n    root4.right.right.right = TreeNode(4)\n    root5 = TreeNode(5)\n    root5.left = TreeNode(8)\n    root5.right = TreeNode(9)\n    root5.left.left = TreeNode(2)\n    root5.left.right = TreeNode(1)\n    root5.right.left = TreeNode(3)\n    root5.right.right = TreeNode(7)\n    test_inputs = [(root1, 1), (root2, 2), (root3, 1), (root4, 3), (root5, 3)]\n    return test_inputs\n"
  },
  "code_baseline": {
    "message": "\n@@@@@CODE@BEGINS@@@@@\n# Let's start by implementing the kthLargestLevelSum function\n\nfrom typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        # First, we will create an empty list to store level sums\n        level_sums = []\n        \n        # We will use a queue to perform level order traversal of the tree\n        queue = []\n        \n        # Initially, add the root node to the queue\n        queue.append(root)\n        \n        # While the queue is not empty, process nodes level by level\n        while queue:\n            # Calculate the number of nodes in the current level\n            level_size = len(queue)\n            \n            # Initialize the sum of values for the current level\n            level_sum = 0\n            \n            # Process all nodes in the current level\n            for i in range(level_size):\n                # Get the first node from the queue\n                node = queue.pop(0)\n                \n                # Add its value to the level sum\n                level_sum += node.val\n                \n                # Add its left child to the queue if it exists\n                if node.left:\n                    queue.append(node.left)\n                \n                # Add its right child to the queue if it exists\n                if node.right:\n                    queue.append(node.right)\n            \n            # Add the level sum to the list of level sums\n            level_sums.append(level_sum)\n        \n        # If there are fewer than k levels, return -1\n        if k > len(level_sums):\n            return -1\n        \n        # Sort the level sums in descending order\n        level_sums.sort(reverse=True)\n        \n        # Return the kth largest level sum\n        return level_sums[k - 1]\n\n# Let's test our implementation with the given test cases\n\n# Test case 1\nroot1 = TreeNode(5)\nroot1.left = TreeNode(8)\nroot1.right = TreeNode(9)\nroot1.left.left = TreeNode(2)\nroot1.left.right = TreeNode(1)\nroot1.right.left = TreeNode(3)\nroot1.right.right = TreeNode(7)\nroot1.left.left.left = TreeNode(4)\nroot1.left.left.right = TreeNode(6)\nresult1 = Solution().kthLargestLevelSum(root1, 2)\nprint(result1)  # Output: 13\n\n# Test case 2\nroot2 = TreeNode(1)\nroot2.left = TreeNode(2)\nroot2.left.left = TreeNode(3)\nresult2 = Solution().kthLargestLevelSum(root2, 1)\nprint(result2)  # Output: 3\n@@@@@CODE@ENDS@@@@@\nThe implementation of the `kthLargestLevelSum` function correctly solves the problem and produces the expected results for the given test cases.\n\nThe function performs a level order traversal of the binary tree, calculates the sum of the values for each level, and stores these sums in the `level_sums` list. It then sorts the list in descending order to find the kth largest level sum. If there are fewer than k levels in the tree, the function returns -1.\n\nThe test cases provided in the problem statement have been successfully passed by the implementation. As a result, it can be concluded that the implementation is correct.",
    "code": "class Solution:\n\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        level_sums = []\n        queue = []\n        queue.append(root)\n        while queue:\n            level_size = len(queue)\n            level_sum = 0\n            for i in range(level_size):\n                node = queue.pop(0)\n                level_sum += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            level_sums.append(level_sum)\n        if k > len(level_sums):\n            return -1\n        level_sums.sort(reverse=True)\n        return level_sums[k - 1]",
    "result": {
      "status_code": 10,
      "lang": "python3",
      "run_success": true,
      "status_runtime": "973 ms",
      "memory": 57544000,
      "question_id": "2646",
      "elapsed_time": 1029,
      "compare_result": "111111111111111111111111111111111111111111111",
      "code_output": "",
      "std_output": "",
      "last_testcase": "",
      "expected_output": "",
      "task_finish_time": 1682898640135,
      "task_name": "judger.judgetask.Judge",
      "finished": true,
      "total_correct": 45,
      "total_testcases": 45,
      "runtime_percentile": 17.02050000000001,
      "status_memory": "57.5 MB",
      "memory_percentile": 23.289400000000022,
      "pretty_lang": "Python3",
      "submission_id": "942328254",
      "status_msg": "Accepted",
      "state": "SUCCESS"
    }
  }
}