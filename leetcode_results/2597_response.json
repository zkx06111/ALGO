{
  "problem": 2597,
  "link_id": "the-number-of-beautiful-subsets",
  "contest": "weekly-contest-337",
  "level": "medium",
  "tags": [
    "Enumeration"
  ],
  "hint1": "Enumerate all possible subsets.",
  "hint2": "Use backtracking to generate all the beautiful subsets. If cnt[nums[i] - k] is positive, then it is impossible to add nums[i] in the subset, and we just move to the next index. Otherwise, it is also possible to add nums[i] in the subset, in this case, increase cnt[nums[i]], and move to the next index.",
  "func_name": "beautifulSubsets",
  "sample_inputs": [
    "[2,4,6]\n2",
    "[1]\n1"
  ],
  "code_brute_force": {
    "id": 2597,
    "code": "class Solution:\n\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        count = 0\n        for i in range(1, 2 ** n):\n            subset = [nums[j] for j in range(n) if i & 1 << j != 0]\n            is_beautiful = True\n            for x in subset:\n                for y in subset:\n                    if x != y and abs(x - y) == k:\n                        is_beautiful = False\n                        break\n                if not is_beautiful:\n                    break\n            if is_beautiful:\n                count += 1\n        return count\n",
    "result": {
      "status_code": 14,
      "lang": "python3",
      "run_success": false,
      "status_runtime": "N/A",
      "memory": 0,
      "question_id": "2696",
      "elapsed_time": 11005,
      "compare_result": "11111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "code_output": "",
      "std_output": "",
      "last_testcase": "[2,14,9,22,20,1,17,15,11,13,7,21,18,24,23,28,19,26,27]\n21",
      "expected_output": "221183",
      "task_finish_time": 1683071313755,
      "task_name": "judger.judgetask.Judge",
      "finished": true,
      "total_correct": 34,
      "total_testcases": 1307,
      "runtime_percentile": null,
      "status_memory": "N/A",
      "memory_percentile": null,
      "pretty_lang": "Python3",
      "submission_id": "943508928",
      "status_msg": "Time Limit Exceeded",
      "state": "SUCCESS"
    }
  },
  "data_validator": {
    "prompt": "You are given this leetcode problem. Please help me by generating a validator function `is_valid_input` that takes exactly the same inputs as the solution function and returns a boolean value indicating whether the input is valid and follows the constraints defined in the problem description. Please test your data validator by checking the validity of the example cases given in the problem description.",
    "full_message": "To create the `is_valid_input` function, we need to check that the given input follows the constraints defined in the problem description. Specifically, we need to verify the following:\n\n1. The length of the array `nums` should be between 1 and 20, inclusive.\n2. Each element in the array `nums` should be a positive integer between 1 and 1000, inclusive.\n3. The integer `k` should be a positive integer between 1 and 1000, inclusive.\n\nWe can implement this function by checking these conditions and returning `True` if all conditions are met and `False` otherwise. Let's implement this validator function and test it with the example cases provided in the problem description.\n@@@@@CODE@BEGINS@@@@@\ndef is_valid_input(nums: List[int], k: int) -> bool:\r\n    # Check the length of the array nums\r\n    if not (1 <= len(nums) <= 20):\r\n        return False\r\n    \r\n    # Check that each element in nums is a positive integer between 1 and 1000\r\n    for num in nums:\r\n        if not (1 <= num <= 1000):\r\n            return False\r\n    \r\n    # Check that k is a positive integer between 1 and 1000\r\n    if not (1 <= k <= 1000):\r\n        return False\r\n    \r\n    # If all conditions are met, return True\r\n    return True\r\n\r\n# Testing the data validator with the example cases\r\nprint(is_valid_input([2,4,6], 2))  # Output: True (Valid input)\r\nprint(is_valid_input([1], 1))       # Output: True (Valid input)\n@@@@@CODE@ENDS@@@@@\nThe `is_valid_input` function correctly validates the input based on the constraints defined in the problem description. Specifically, the function returns `True` for the example cases ([2,4,6], 2) and ([1], 1), indicating that these inputs are valid and adhere to the specified constraints.\n\nThe validator function checks the length of the array `nums`, the range of each element in `nums`, and the range of the integer `k` to determine whether the input is valid. The implementation is successful in ensuring that the input satisfies the constraints given in the problem description.",
    "code": "def is_valid_input(nums: List[int], k: int) -> bool:\n    if not 1 <= len(nums) <= 20:\n        return False\n    for num in nums:\n        if not 1 <= num <= 1000:\n            return False\n    if not 1 <= k <= 1000:\n        return False\n    return True\n"
  },
  "data_generator": {
    "prompt": "You are given this leetcode problem and its test input validator `is_valid_input`. Please help me by generating an input generator function `gen_input` that randomly generates test inputs which follow the constraints defined. Your `gen_input` function should make use of `is_valid_input` by validating the generated input with it. Your function should only generate test inputs and not test outputs.",
    "full_message": "To create the `gen_input` function, we'll randomly generate test inputs that satisfy the constraints defined in the problem description. We'll make use of the `is_valid_input` function to validate the generated inputs. Specifically, the `gen_input` function will do the following:\n\n1. Randomly determine the length of the array `nums` within the range [1, 20].\n2. Randomly generate elements for the array `nums` such that each element is a positive integer between 1 and 1000, inclusive.\n3. Randomly generate the integer `k` such that it is a positive integer between 1 and 1000, inclusive.\n4. Check whether the generated input is valid using the `is_valid_input` function. If the input is valid, return it; otherwise, repeat the process.\n\nLet's implement this input generator function.\n@@@@@CODE@BEGINS@@@@@\nimport random\r\n\r\ndef gen_input() -> tuple:\r\n    # Helper function to check if a generated input is valid\r\n    def is_valid_input(nums: List[int], k: int) -> bool:\r\n        if not (1 <= len(nums) <= 20):\r\n            return False\r\n        for num in nums:\r\n            if not (1 <= num <= 1000):\r\n                return False\r\n        if not (1 <= k <= 1000):\r\n            return False\r\n        return True\r\n    \r\n    while True:\r\n        # Randomly determine the length of the array nums\r\n        n = random.randint(1, 20)\r\n        \r\n        # Randomly generate elements for the array nums\r\n        nums = [random.randint(1, 1000) for _ in range(n)]\r\n        \r\n        # Randomly generate the integer k\r\n        k = random.randint(1, 1000)\r\n        \r\n        # Check if the generated input is valid\r\n        if is_valid_input(nums, k):\r\n            return (nums, k)\r\n\r\n# Generating and displaying 5 random test inputs\r\nfor _ in range(5):\r\n    print(gen_input())\n@@@@@CODE@ENDS@@@@@\nThe `gen_input` function successfully generates random test inputs that satisfy the constraints defined in the problem description. For each generated input, the function randomly determines the length of the array `nums`, randomly generates the elements of `nums`, and randomly generates the integer `k`. It then checks whether the generated input is valid using the `is_valid_input` function.\n\nIn the output above, we can see that the function generates different inputs each time it is called. Each input is a tuple consisting of an array `nums` and an integer `k`. The inputs generated satisfy the constraints of the problem (e.g., the length of `nums` is within the range [1, 20], each element of `nums` is between 1 and 1000, and `k` is between 1 and 1000). This makes the `gen_input` function suitable for generating test inputs for the problem.",
    "code": "def gen_input() -> tuple:\n\n    def is_valid_input(nums: List[int], k: int) -> bool:\n        if not 1 <= len(nums) <= 20:\n            return False\n        for num in nums:\n            if not 1 <= num <= 1000:\n                return False\n        if not 1 <= k <= 1000:\n            return False\n        return True\n    while True:\n        n = random.randint(1, 20)\n        nums = [random.randint(1, 1000) for _ in range(n)]\n        k = random.randint(1, 1000)\n        if is_valid_input(nums, k):\n            return (nums, k)\n"
  },
  "data_random_generator": {
    "prompt": "You are given this leetcode problem, its random input generator `gen_input`, and its brute-force solution `BruteforceSolution`. Please help me by generating 5 random inputs with the random input generator `gen_input`. You should return a function named `random_test()` that takes several arguments to control the upper limit of the input and returns a list of 5 tuples. You do not need to generate test outputs, only generate inputs.",
    "full_message": "To create the `random_test` function, we can use the provided `gen_input` function as a base. We'll modify it to accept additional arguments to control the upper limit of the input. Specifically, the `random_test` function will take the following arguments:\n\n- `max_n`: The maximum length of the array `nums`.\n- `max_num`: The maximum value for each element in the array `nums`.\n- `max_k`: The maximum value for the integer `k`.\n\nThe function will return a list of 5 tuples, each representing a random test input generated based on the specified upper limits.\n\nLet's implement the `random_test` function and use it to generate 5 random inputs.\n@@@@@CODE@BEGINS@@@@@\nfrom typing import List, Tuple\r\n\r\ndef random_test(max_n: int = 20, max_num: int = 1000, max_k: int = 1000) -> List[Tuple[List[int], int]]:\r\n    # Helper function to check if a generated input is valid\r\n    def is_valid_input(nums: List[int], k: int) -> bool:\r\n        if not (1 <= len(nums) <= max_n):\r\n            return False\r\n        for num in nums:\r\n            if not (1 <= num <= max_num):\r\n                return False\r\n        if not (1 <= k <= max_k):\r\n            return False\r\n        return True\r\n    \r\n    def gen_input() -> Tuple[List[int], int]:\r\n        while True:\r\n            # Randomly determine the length of the array nums\r\n            n = random.randint(1, max_n)\r\n\r\n            # Randomly generate elements for the array nums\r\n            nums = [random.randint(1, max_num) for _ in range(n)]\r\n\r\n            # Randomly generate the integer k\r\n            k = random.randint(1, max_k)\r\n\r\n            # Check if the generated input is valid\r\n            if is_valid_input(nums, k):\r\n                return (nums, k)\r\n    \r\n    # Generate 5 random test inputs\r\n    test_inputs = [gen_input() for _ in range(5)]\r\n    \r\n    return test_inputs\r\n\r\n# Generating and displaying 5 random test inputs with default upper limits\r\nprint(random_test())\n@@@@@CODE@ENDS@@@@@\nThe `random_test` function successfully generates 5 random test inputs based on the specified upper limits. Each test input is represented as a tuple consisting of an array `nums` and an integer `k`. The function ensures that the generated inputs satisfy the constraints defined in the problem description, as well as the additional upper limits provided as arguments.\n\nIn the output above, we can see that the function generates a list of 5 random test inputs with default upper limits (`max_n=20`, `max_num=1000`, and `max_k=1000`). The inputs generated are valid and can be used for testing the brute-force solution `BruteforceSolution`.\n\nUsers can also customize the upper limits by providing different values for the `max_n`, `max_num`, and `max_k` arguments when calling the `random_test` function.",
    "code": "def random_test(max_n: int=20, max_num: int=1000, max_k: int=1000) -> List[Tuple[List[int], int]]:\n\n    def is_valid_input(nums: List[int], k: int) -> bool:\n        if not 1 <= len(nums) <= max_n:\n            return False\n        for num in nums:\n            if not 1 <= num <= max_num:\n                return False\n        if not 1 <= k <= max_k:\n            return False\n        return True\n\n    def gen_input() -> Tuple[List[int], int]:\n        while True:\n            n = random.randint(1, max_n)\n            nums = [random.randint(1, max_num) for _ in range(n)]\n            k = random.randint(1, max_k)\n            if is_valid_input(nums, k):\n                return (nums, k)\n    test_inputs = [gen_input() for _ in range(5)]\n    return test_inputs\n"
  },
  "data_tricky_generator": {
    "prompt": "You are given this leetcode problem. Please help me by generating some special and tricky test inputs by the function `special_tricky_test_inputs()` that may break the user's program. Make sure that your test inputs follow the constraints defined in the problem. Do not generate test outputs, only generate inputs.",
    "full_message": "To create the `special_tricky_test_inputs` function, we'll generate test inputs that cover edge cases, corner cases, and scenarios that might be challenging to handle in the user's program. The following are some special and tricky test inputs:\n\n1. A case with the minimum possible values of `nums` and `k`. This tests the lower edge of the input range.\n2. A case with the maximum possible value of `k` and an array `nums` containing consecutive integers. This tests the ability to handle large values of `k`.\n3. A case with the maximum possible length of `nums` (i.e., 20) where all elements are equal. This tests the ability to handle arrays with duplicate elements.\n4. A case where `nums` has both consecutive and non-consecutive elements, making it harder to determine beautiful subsets.\n5. A case with `k` equal to the range of `nums` such that there is only one beautiful subset.\n\nLet's implement the `special_tricky_test_inputs` function and generate these test inputs.\n@@@@@CODE@BEGINS@@@@@\ndef special_tricky_test_inputs() -> List[Tuple[List[int], int]]:\n    test_inputs = [\n        # Test the lower edge of the input range\n        ([1], 1),\n        \n        # Test the ability to handle large values of k\n        ([1, 2, 3, 4, 5], 1000),\n        \n        # Test the ability to handle arrays with duplicate elements\n        ([7] * 20, 5),\n        \n        # Test cases with both consecutive and non-consecutive elements\n        ([2, 4, 6, 8, 10, 15, 20, 25], 2),\n        \n        # Test cases with k equal to the range of nums\n        ([10, 20, 30], 10)\n    ]\n    return test_inputs\n\n# Generating and displaying special and tricky test inputs\nprint(special_tricky_test_inputs())\n@@@@@CODE@ENDS@@@@@\nThe `special_tricky_test_inputs` function successfully generates a set of special and tricky test inputs that may be challenging for the user's program to handle. These inputs cover various scenarios, including lower and upper edge cases, arrays with duplicate elements, cases with both consecutive and non-consecutive elements, and cases where `k` is equal to the range of `nums`.\n\nThe generated test inputs are as follows:\n\n1. ([1], 1): A case with the minimum possible values of `nums` and `k`.\n2. ([1, 2, 3, 4, 5], 1000): A case with a large value of `k` and an array `nums` with consecutive integers.\n3. ([7, 7, 7, ..., 7], 5): A case with the maximum possible length of `nums` (i.e., 20) where all elements are equal.\n4. ([2, 4, 6, 8, 10, 15, 20, 25], 2): A case with both consecutive and non-consecutive elements in `nums`.\n5. ([10, 20, 30], 10): A case with `k` equal to the range of `nums`.\n\nThese test inputs adhere to the constraints defined in the problem and are designed to test the robustness of the user's program. They can be used to check whether the program can handle different scenarios and edge cases correctly.",
    "code": "def special_tricky_test_inputs() -> List[Tuple[List[int], int]]:\n    test_inputs = [([1], 1), ([1, 2, 3, 4, 5], 1000), ([7] * 20, 5), ([2, 4, 6, 8, 10, 15, 20, 25], 2), ([10, 20, 30], 10)]\n    return test_inputs\n"
  },
  "code_baseline": {
    "message": "\n@@@@@CODE@BEGINS@@@@@\nfrom typing import List\n\nclass Solution:\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\n        # Count the occurrences of each number in the array\n        count = {}\n        for num in nums:\n            if num not in count:\n                count[num] = 0\n            count[num] += 1\n        \n        # Calculate the number of beautiful subsets by counting the number of subsets\n        # that do not contain two numbers with absolute difference equal to k\n        result = 0\n        for i in range(1, 1 << len(nums)):\n            subset = []\n            for j in range(len(nums)):\n                if i & (1 << j):\n                    subset.append(nums[j])\n            is_beautiful = True\n            for a in range(len(subset)):\n                for b in range(a + 1, len(subset)):\n                    if abs(subset[a] - subset[b]) == k:\n                        is_beautiful = False\n                        break\n                if not is_beautiful:\n                    break\n            if is_beautiful:\n                result += 1\n        return result\n\n# Test cases\nsolution = Solution()\nprint(solution.beautifulSubsets([2,4,6], 2)) # Output: 4\nprint(solution.beautifulSubsets([1], 1)) # Output: 1\n@@@@@CODE@ENDS@@@@@\nThe implementation of the `beautifulSubsets` function correctly solves the problem and passes the provided test cases. The function uses a brute-force approach to generate all possible subsets of the array `nums` and then checks each subset to see if it is beautiful or not. A subset is considered beautiful if it does not contain two integers with an absolute difference equal to `k`.\n\nIn the test cases, we can see that the function returns the expected outputs:\n- For `nums = [2,4,6]` and `k = 2`, the beautiful subsets are `[2]`, `[4]`, `[6]`, and `[2, 6]`, resulting in an output of `4`.\n- For `nums = [1]` and `k = 1`, the only beautiful subset is `[1]`, resulting in an output of `1`.\n\nSince the problem's constraints specify that the length of the array `nums` is at most 20, the brute-force approach used by the function is acceptable in terms of time complexity. However, if the size of the input array were larger, a more efficient approach would be needed to solve the problem.",
    "code": "class Solution:\n\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\n        count = {}\n        for num in nums:\n            if num not in count:\n                count[num] = 0\n            count[num] += 1\n        result = 0\n        for i in range(1, 1 << len(nums)):\n            subset = []\n            for j in range(len(nums)):\n                if i & 1 << j:\n                    subset.append(nums[j])\n            is_beautiful = True\n            for a in range(len(subset)):\n                for b in range(a + 1, len(subset)):\n                    if abs(subset[a] - subset[b]) == k:\n                        is_beautiful = False\n                        break\n                if not is_beautiful:\n                    break\n            if is_beautiful:\n                result += 1\n        return result",
    "result": {
      "status_code": 14,
      "lang": "python3",
      "run_success": false,
      "status_runtime": "N/A",
      "memory": 0,
      "question_id": "2696",
      "elapsed_time": 11005,
      "compare_result": "11111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "code_output": "",
      "std_output": "",
      "last_testcase": "[2,14,9,22,20,1,17,15,11,13,7,21,18,24,23,28,19,26,27]\n21",
      "expected_output": "221183",
      "task_finish_time": 1682900405555,
      "task_name": "judger.judgetask.Judge",
      "finished": true,
      "total_correct": 34,
      "total_testcases": 1307,
      "runtime_percentile": null,
      "status_memory": "N/A",
      "memory_percentile": null,
      "pretty_lang": "Python3",
      "submission_id": "942335760",
      "status_msg": "Time Limit Exceeded",
      "state": "SUCCESS"
    }
  }
}