{"tags": ["Array", "String", "Hash Table", "Math", "Dynamic Programming", "Sorting", "Greedy", "Depth-First Search", "Binary Search", "Database", "Breadth-First Search", "Tree", "Matrix", "Two Pointers", "Binary Tree", "Bit Manipulation", "Heap (Priority Queue)", "Stack", "Graph", "Prefix Sum", "Design", "Simulation", "Counting", "Backtracking", "Sliding Window", "Union Find", "Linked List", "Ordered Set", "Monotonic Stack", "Enumeration", "Recursion", "Trie", "Divide and Conquer", "Binary Search Tree", "Bitmask", "Queue", "Number Theory", "Memoization", "Segment Tree", "Geometry", "Topological Sort", "Binary Indexed Tree", "Hash Function", "Game Theory", "Combinatorics", "Shortest Path", "Data Stream", "Interactive", "String Matching", "Rolling Hash", "Brainteaser", "Randomized", "Monotonic Queue", "Merge Sort", "Iterator", "Concurrency", "Doubly-Linked List", "Probability and Statistics", "Quickselect", "Bucket Sort", "Suffix Array", "Minimum Spanning Tree", "Counting Sort", "Shell", "Line Sweep", "Reservoir Sampling", "Eulerian Circuit", "Radix Sort", "Strongly Connected Component", "Rejection Sampling", "Biconnected Component"], "problems": [{"problem": 2582, "link_id": "pass-the-pillow", "contest": "weekly-contest-335", "level": "easy", "tags": ["Math", "Simulation"], "hint1": "Every 2 * (n - 1) passes is a cycle.", "hint2": "Every 2 * (n - 1) is a cycle, so we first modulo time with 2 * (n - 1), i.e., time = time % 2 * (n - 1). Then if time <= n - 1, the pillow is given to time + 1 person. Otherwise, the pillow is given to n - (time - (n - 1)) person.", "func_name": "passThePillow", "sample_inputs": ["4\n5", "3\n2"]}, {"problem": 2583, "link_id": "kth-largest-sum-in-a-binary-tree", "contest": "weekly-contest-335", "level": "medium", "tags": ["Binary Tree", "Depth-First Search"], "hint1": "Depth-first search the tree and keep track of depth and sum of values.", "hint2": "Depth-first search the tree based on the TreeNode, and then summing the values of node with the same depth in a list. Then find the kth largest element in the list.", "func_name": "kthLargestLevelSum", "sample_inputs": ["[5,8,9,2,1,3,7,4,6]\n2", "[1,2,null,3]\n1"]}, {"problem": 2584, "link_id": "split-the-array-to-make-coprime-products", "contest": "weekly-contest-335", "level": "hard", "tags": ["Math"], "hint1": "Each prime factor only appears in the same split but not both. Prime factor decomposition of numbers can be done efficiently.", "hint2": "Record the right-most index of each prime factor into a dictionary. Then we scan from left to right and keep updating the right-most index of prime factors scanned so far. If the current right-most index is 'i' itself, that means 'i' is the smallest splitting point.", "func_name": "findValidSplit", "sample_inputs": ["[4,7,8,15,3,5]", "[4,7,15,8,3,5]"]}, {"problem": 2585, "link_id": "number-of-ways-to-earn-points", "contest": "weekly-contest-335", "level": "hard", "tags": ["Dynamic Programming"], "hint1": "Multiple knapsack dynamic programming.", "hint2": "Let ways[i][points] be the number of ways to score a given number of points after solving some questions of the first i types. ways[i][points] is equal to the sum of ways[i-1][points - solved * marks[i]] over 0 <= solved <= count_i.", "func_name": "waysToReachTarget", "sample_inputs": ["6\n[[6,1],[3,2],[2,3]]", "5\n[[50,1],[50,2],[50,5]]", "18\n[[6,1],[3,2],[2,3]]"]}, {"problem": 2586, "link_id": "count-the-number-of-vowel-strings-in-range", "contest": "weekly-contest-336", "level": "easy", "tags": ["String"], "hint1": "", "hint2": "Iterate over strings in words[left : right + 1] and examine each string to see if starts and ends with vowel.", "func_name": "vowelStrings", "sample_inputs": ["[\"are\",\"amy\",\"u\"]\n0\n2", "[\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"]\n1\n4"]}, {"problem": 2587, "link_id": "rearrange-array-to-maximize-prefix-score", "contest": "weekly-contest-336", "level": "medium", "tags": ["Sorting"], "hint1": "The best order is decreasing order.", "hint2": "Sort the array in decreasing order and count the number of positive values in the prefix sum array.", "func_name": "maxScore", "sample_inputs": ["[2,-1,0,1,-3,3,-3]", "[-2,-3,0]"]}, {"problem": 2588, "link_id": "count-the-number-of-beautiful-subarrays", "contest": "weekly-contest-336", "level": "medium", "tags": ["Bit Manipulation", "Prefix Sum"], "hint1": "A subarray is beautiful if its xor is equal to zero.", "hint2": "A subarray is beautiful if its xor is equal to zero. Compute the prefix xor for every index, then the xor of subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0. Iterate from left to right and maintain a hash table to count the number of indices equal to the current prefix xor.", "func_name": "beautifulSubarrays", "sample_inputs": ["[4,3,1,2,4]", "[1,10,4]"]}, {"problem": 2589, "link_id": "minimum-time-to-complete-all-tasks", "contest": "weekly-contest-336", "level": "hard", "tags": ["Greedy", "Sorting"], "hint1": "The minimum time is achieved when the overlap of tasks is maximized.", "hint2": "Sort the tasks in ascending order of end time. Since there are only up to 2000 time points to consider, you can check them one by one. It is always beneficial to run the task as late as possible so that later tasks can run simultaneously.", "func_name": "findMinimumTime", "sample_inputs": ["[[2,3,1],[4,5,1],[1,5,2]]", "[[1,3,2],[2,5,3],[5,6,2]]"]}, {"problem": 2591, "link_id": "distribute-money-to-maximum-children", "contest": "biweekly-contest-100", "level": "easy", "tags": ["Enumeration"], "hint1": "", "hint2": "Enumerate the number of children who receive exactly 8 dollars. Check if it is possible to distribute the rest money to the remaining children following the rule.", "func_name": "distMoney", "sample_inputs": ["20\n3", "16\n2"]}, {"problem": 2592, "link_id": "maximize-greatness-of-an-array", "contest": "biweekly-contest-100", "level": "medium", "tags": ["Sorting"], "hint1": "Each nums[i] should be greater by perm[i] that is as minimum as possible.", "hint2": "Sort the nums array in ascending order. Assign every element nums[i] the next bigger unused element nums[j] as many times as possible..", "func_name": "maximizeGreatness", "sample_inputs": ["[1,3,5,2,1,3,1]", "[1,2,3,4]"]}, {"problem": 2593, "link_id": "find-score-of-an-array-after-marking-all-elements", "contest": "biweekly-contest-100", "level": "medium", "tags": ["Sorting"], "hint1": "Try simulating the process of marking the elements and their adjacent.", "hint2": "Sort (nums[i], i) in ascending order. Simulating the process of marking the elements and their adjacent. If there is an element that was already marked, then you skip it.", "func_name": "findScore", "sample_inputs": ["[2,1,3,4,5,2]", "[2,3,5,1,3,2]"]}, {"problem": 2594, "link_id": "minimum-time-to-repair-cars", "contest": "biweekly-contest-100", "level": "medium", "tags": ["Binary Search"], "hint1": "For a predefined fixed time, can all the cars be repaired?", "hint2": "Binary search the minimum time. Given a predefined minimum time, assign each mechanic as more cars as possible and check if all cars can be assigned.", "func_name": "repairCars", "sample_inputs": ["[4,2,3,1]\n10", "[5,1,8]\n6"]}, {"problem": 2595, "link_id": "number-of-even-and-odd-bits", "contest": "weekly-contest-337", "level": "easy", "tags": ["Bit Manipulation"], "hint1": "", "hint2": "Divide n by 2 while n is positive, and if n modulo 2 is 1, add 1 to even or odd variable depending on its binary index.", "func_name": "evenOddBit", "sample_inputs": ["17", "2"]}, {"problem": 2596, "link_id": "check-knight-tour-configuration", "contest": "weekly-contest-337", "level": "medium", "tags": ["Array"], "hint1": "Two successive rows and cols are valid if row differs 1 and col differs 2 or row differs 2 and col differs 1.", "hint2": "Evaluate every two successive rows and cols and check if they are valid. Two successive rows and cols are valid if row differs 1 and col differs 2 or row differs 2 and col differs 1.", "func_name": "checkValidGrid", "sample_inputs": ["[[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]", "[[0,3,6],[5,8,1],[2,7,4]]"]}, {"problem": 2597, "link_id": "the-number-of-beautiful-subsets", "contest": "weekly-contest-337", "level": "medium", "tags": ["Enumeration"], "hint1": "Enumerate all possible subsets.", "hint2": "Use backtracking to generate all the beautiful subsets. If cnt[nums[i] - k] is positive, then it is impossible to add nums[i] in the subset, and we just move to the next index. Otherwise, it is also possible to add nums[i] in the subset, in this case, increase cnt[nums[i]], and move to the next index.", "func_name": "beautifulSubsets", "sample_inputs": ["[2,4,6]\n2", "[1]\n1"]}, {"problem": 2598, "link_id": "smallest-missing-non-negative-integer-after-operations", "contest": "weekly-contest-337", "level": "medium", "tags": ["Math", "Counting"], "hint1": "Think about using modular arithmetic.", "hint2": "For an element n, we can achieve the minimum non-negative value of n % value. We can also transform element n to n % value + k * value. So, we first count moduli we can get from all numbers. Then, we iterate i from zero upwards, and check if we have a modulo (i % value) that we can tranform to i. If so, we decrease the counter for that modulo. If the counter is zero, we cannot produce i and it's our missing value.", "func_name": "findSmallestInteger", "sample_inputs": ["[1,-10,7,13,6,8]\n5", "[1,-10,7,13,6,8]\n7"]}, {"problem": 2600, "link_id": "k-items-with-the-maximum-sum", "contest": "weekly-contest-338", "level": "easy", "tags": [""], "hint1": "", "hint2": "If k <= numOnes, return k. If numOnes < k <= yinumOnes + numZeros, return numOnes. Otherwise, return numOnes - (k - numOnes - numZeros).", "func_name": "kItemsWithMaximumSum", "sample_inputs": ["3\n2\n0\n2", "3\n2\n0\n4"]}, {"problem": 2601, "link_id": "prime-subtraction-operation", "contest": "weekly-contest-338", "level": "medium", "tags": ["Greedy", "Math"], "hint1": "Think about if we have many primes to subtract from nums[i]. Which prime is more optimal?", "hint2": "The most optimal prime to subtract from nums[i] is the one that makes nums[i] the smallest as possible and greater than nums[i-1]. Use seive algorithm to find all prime numbers <= 1000. Then for each value v record the largest prime that is smaller than v as prev[v].", "func_name": "primeSubOperation", "sample_inputs": ["[4,9,6,10]", "[6,8,11,12]", "[5,8,3]"]}, {"problem": 2602, "link_id": "minimum-operations-to-make-all-array-elements-equal", "contest": "weekly-contest-338", "level": "medium", "tags": ["Binary Search", "Sorting"], "hint1": "For each query, you should decrease all elements greater than queries[i] and increase all elements less than queries[i].", "hint2": "Sort the array nums. Binary search over sorted nums to find index of query[i] be idx. Then use prefix sums to find sum of number smaller and larger than query[i]. Let prefix[i] be sum of sorted nums from 0 to i. query[i] * idx - prefix[idx] is increments required. prefix[n] - prefix[idx] - query[i] * (n - idx) is decrements required.", "func_name": "minOperations", "sample_inputs": ["[3,1,6,8]\n[1,5]", "[2,9,6,3]\n[10]"]}, {"problem": 2603, "link_id": "collect-coins-in-a-tree", "contest": "weekly-contest-338", "level": "hard", "tags": ["Tree"], "hint1": "All leaves that do not have a coin are redundant and can be deleted from the tree.", "hint2": "Remove the leaves that do not have coins on them, so that the resulting tree will have a coin on every leaf. In the remaining tree, remove each leaf node and its parent from the tree. The remaining nodes in the tree are the ones that must be visited. Hence, the answer is equal to (# remaining nodes -1) * 2", "func_name": "collectTheCoins", "sample_inputs": ["[1,0,0,0,0,1]\n[[0,1],[1,2],[2,3],[3,4],[4,5]]", "[0,0,0,1,1,0,0,1]\n[[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]"]}, {"problem": 2609, "link_id": "find-the-longest-balanced-substring-of-a-binary-string", "contest": "weekly-contest-339", "level": "easy", "tags": ["String"], "hint1": "Consider iterating over each subarray and checking if it\u2019s balanced or not.", "hint2": "Among all balanced subarrays, the answer is the longest one of them.", "func_name": "findTheLongestBalancedSubstring", "sample_inputs": ["\"01000111\"", "\"00111\"", "\"111\""]}, {"problem": 2610, "link_id": "convert-an-array-into-a-2d-array-with-conditions", "contest": "weekly-contest-339", "level": "medium", "tags": ["Greedy"], "hint1": "Process the elements in the array one by one in any order and only create a new row in the matrix when we cannot put it into the existing rows", "hint2": "We can simply iterate over the existing rows of the matrix to see if we can place each element.", "func_name": "findMatrix", "sample_inputs": ["[1,3,4,1,2,3,1]", "[1,2,3,4]"]}, {"problem": 2611, "link_id": "mice-and-cheese", "contest": "weekly-contest-339", "level": "medium", "tags": ["Greedy"], "hint1": "Consider the case when the first mouse eats all types of cheese, consider which types are optimal to be given to the second instead.", "hint2": "Imagine at first that the second mouse eats all the cheese, then we should choose k types of cheese with the maximum sum of - reward2[i] + reward1[i].", "func_name": "miceAndCheese", "sample_inputs": ["[1,1,3,4]\n[4,4,1,1]\n2", "[1,1]\n[1,1]\n2"]}, {"problem": 2612, "link_id": "minimum-reverse-operations", "contest": "weekly-contest-339", "level": "hard", "tags": ["Breadth-First Search"], "hint1": "Use a breadth-first search to find the minimum number of operations.", "hint2": "Find the beginning and end indices of the subarray of size k that can be reversed to bring 1 to a particular position.", "func_name": "minReverseOperations", "sample_inputs": ["4\n0\n[1,2]\n4", "5\n0\n[2,4]\n3", "4\n2\n[0,1,3]\n1"]}, {"problem": 2614, "link_id": "prime-in-diagonal", "contest": "weekly-contest-340", "level": "easy", "tags": ["Math", "Number Theory"], "hint1": "Consider how to compute a prime number in a diagonal.", "hint2": "Pick the largest prime in diagonal.", "func_name": "diagonalPrime", "sample_inputs": ["[[1,2,3],[5,6,7],[9,10,11]]", "[[1,2,3],[5,17,7],[9,11,10]]"]}, {"problem": 2615, "link_id": "sum-of-distances", "contest": "weekly-contest-340", "level": "medium", "tags": ["Prefix Sum"], "hint1": "For each number x, collect all the indices where x occurs, and calculate the prefix sum of the array.", "hint2": "For each occurrence of x, the indices to the right will be regular subtraction while the indices to the left will be reversed subtraction.", "func_name": "distance", "sample_inputs": ["[1,3,1,1,2]", "[0,5,3]"]}, {"problem": 2616, "link_id": "minimize-the-maximum-difference-of-pairs", "contest": "weekly-contest-340", "level": "medium", "tags": ["Dynamic Programming", "Sorting"], "hint1": "The pairs of integers selected can only be adjacent elements in the sorted array.", "hint2": "The recurrence relation is fn(i, x) = min(fn(i+1, x), max(abs(nums[i]-nums[i+1]), fn(i+2, p-1)), and fn(0,p) gives the desired answer.", "func_name": "minimizeMax", "sample_inputs": ["[10,1,2,7,1,3]\n2", "[4,2,1,2]\n1"]}, {"problem": 2617, "link_id": "minimum-number-of-visited-cells-in-a-grid", "contest": "weekly-contest-340", "level": "hard", "tags": ["Dynamic Programming", "Heap (Priority Queue)"], "hint1": "For each cell (i,j), it is critical to find out the minimum number of steps to reach (i,j), denoted dis[i][j], quickly, given the tight constraint.", "hint2": "Suppose we want to calculate dis[i][j], keep track of a priority queue that stores (dis[i][k], i, k) for all k \u2264 j, and another priority queue that stores (dis[k][j], k, j) for all k \u2264 i.", "func_name": "minimumVisitedCells", "sample_inputs": ["[[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]", "[[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]", "[[2,1,0],[1,0,0]]"]}, {"problem": 2639, "link_id": "find-the-width-of-columns-of-a-grid", "contest": "biweekly-contest-102", "level": "easy", "tags": ["String"], "hint1": "Compute all the widths for each column.", "hint2": "Pay attention to the negative sign.", "func_name": "findColumnWidth", "sample_inputs": ["[[1],[22],[333]]", "[[-15,1,3],[15,7,12],[5,6,-2]]"]}, {"problem": 2640, "link_id": "find-the-score-of-all-prefixes-of-an-array", "contest": "biweekly-contest-102", "level": "medium", "tags": [""], "hint1": "For every prefix, compute the its conversion, and then compute the scores", "hint2": "The maximum of a prefix is the maximum of the previous prefix and the current value.", "func_name": "findPrefixScore", "sample_inputs": ["[2,3,7,5,10]", "[1,1,2,4,8,16]"]}, {"problem": 2641, "link_id": "cousins-in-binary-tree-ii", "contest": "biweekly-contest-102", "level": "medium", "tags": ["Binary Tree", "Depth-First Search"], "hint1": "Cousins are at the same depth, and have different parents", "hint2": "Compute the depths and parents for every node.", "func_name": "replaceValueInTree", "sample_inputs": ["[5,4,9,1,10,null,7]", "[3,1,2]"]}, {"problem": 2643, "link_id": "row-with-maximum-ones", "contest": "weekly-contest-341", "level": "easy", "tags": [""], "hint1": "", "hint2": "For every row, compute the number of ones in it. Then pick the one with the largest number.", "func_name": "rowAndMaximumOnes", "sample_inputs": ["[[0,1],[1,0]]", "[[0,0,0],[0,1,1]]", "[[0,0],[1,1],[0,0]]"]}, {"problem": 2644, "link_id": "find-the-maximum-divisibility-score", "contest": "weekly-contest-341", "level": "easy", "tags": ["Math"], "hint1": "", "hint2": "For every divisor, use bruteforce to compute its divisibility score.", "func_name": "maxDivScore", "sample_inputs": ["[4,7,9,3,9]\n[5,2,3]", "[20,14,21,10]\n[5,7,5]", "[12]\n[10,16]"]}, {"problem": 2645, "link_id": "minimum-additions-to-make-valid-string", "contest": "weekly-contest-341", "level": "medium", "tags": ["Greedy"], "hint1": "Consider different cases where the first character of the string is a or b or c", "hint2": "When the first character is a, if the prefix is ab or ac then we need to insert one more character, otherwise we need to insert two more. When the first character is b, if the prefix is bc, we need to insert one more, otherwise two more. When the first character is c, we need to insert two more characters.", "func_name": "addMinimum", "sample_inputs": ["\"b\"", "\"aaa\"", "\"abc\""]}, {"problem": 2646, "link_id": "minimize-the-total-price-of-the-trips", "contest": "weekly-contest-341", "level": "hard", "tags": ["Dynamic Programming", "Depth-First Search"], "hint1": "Every node's contribution to the total price is its price * its frequency of being visited. For every node, consider whether to halve its price or not", "hint2": "Use dp[node][0/1] to store the minimum total price of the subtree of node, where 0 means not halving the price of node, and 1 means halving the price of node. dp[node][0] can be updated by dp[child][0/1], dp[node][1] can only be updated by dp[child][1]", "func_name": "minimumTotalPrice", "sample_inputs": ["4\n[[0,1],[1,2],[1,3]]\n[2,2,10,6]\n[[0,3],[2,1],[2,3]]", "2\n[[0,1]]\n[2,2]\n[[0,0]]"]}]}